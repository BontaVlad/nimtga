#+REVEAL_ROOT: http://cdn.jsdelivr.net/reveal.js/3.0.0/
# #+REVEAL_ROOT: file:////home/Experiments/nimtga/presentation/reveal.js-2.1
#+OPTIONS: toc:nil num:nil reveal_title_slide:nil
#+TITLE: To C or not to C, let Nim anwser the question!
#+AUTHOR: Bonta Sergiu Vlad
#+EMAIL: bonta.vlad@gmail.com

* To C or not to C, let Nim answer the question!
* Table of content
#+ATTR_REVEAL: :frag (roll-in)
- Introduction
- Looking for trouble
- Getting out of trouble
- Did I get out of trouble?
- Hello, is it Nim you're looking for?
* Who is this 'me' I'm talking about?
*Bonta Sergiu Vlad*

Email/contact: *bonta.vlad@gmail.com* or just google my name

Web developer for about 3 years(it's less then 3 but not by much)

Me knows mostly *Python* and *Javascript*
* Buyers beware
#+ATTR_REVEAL: :frag (roll-in)
- I am you're average Joe programmer. No fancy big corporation, no big project, not much experience.
- Every benchmark out there lies, this included.
- I am very biased towards Nim.
* Looking for trouble
 *"Every Fairy Tale Needs A Good Old Fashioned Villain"*
- cpu intensive
- relative easy to explain
- somehow similar to a real use case
* The villain
We have around 1000 Truevision images that we want to open, 
fill the first 5 pixels with red color(simulate a watermark?) and finally save it.
* The need for speed: Hot pursuit two!
It's a batch process

Each delay will add up!

Image sizes: 15, 150, 512, 1024, 2048 and 4096 pixels wide.

Smaller image size to tax JIT solutions(warm up time), bigger images sizes to see how well a solution scales or help JIT shine at it's best advantage(tight loops).
* Truevision image format or *.tga
Often referred to as targa: raster graphics format.

Why tga?

Simple compression algorithm.

Used is computer graphics so it has some use cases.

Found a python package that I could port(copy).
* TGA structure

| header               | pixel data     | footer           |
|----------------------+----------------+------------------|
| id length            | RLE            | Extension offset |
| ...                  | or             | ...              |
| image specifications | no compression | Signature        |


Pixel structure:
- Grayscale - 8 bit depth
- RGB - 16 bit depth
- RGB - 24 bit depth
- RGBA - 32 bit depth
* RLE compression algorithm Run-length encoding (RLE) 
lossless data compression 

A hypothetical scan line, with B representing a black pixel and W representing white, might read as follows:

~WWWWBBBWWBBBBBBW~ 

With a run-length encoding (RLE) data compression algorithm applied to the above hypothetical scan line, it can be rendered as follows:

~4W3B2W6B1W~
* Getting out of trouble
Now that we know our "villain" how can we overcome it?
* Keep it simple stupid!
Maybe we can dodge a bullet by using more "cleaner" ways of getting the required speed

We do not strive for the fastest implementation, we strive for "good enough" with minimal, preferably *none*, development time
* cPython


The hero we need, the hero we want(well most of the time at least)!

The slowest implementation, but good reference point

Serves as blueprint for the Nim implementation

** 
#+BEGIN_SRC python
  class TGAHeader(object):
      def __init__(self):
          self.id_length = 0
          self.color_map_type = 0
          self.image_type = 0
          # ...


  class TGAFooter(object):

      def __init__(self):
          self.extension_area_offset = 0
          self.developer_directory_offset = 0
          self.signature = "TRUEVISION-XFILE"
          # ...

#+END_SRC

** 
#+BEGIN_SRC python
  class Image(object):

      def __init__(self):
          self._header = TGAHeader()
          self._footer = TGAFooter()
          self._pixels = []

      def load(self, file_name):
          pass
          # ...

      def save(self, file_name, original_format=False, force_16_bit=False,
               compress=False):
          pass
          # ...


  @staticmethod
  def _encode(row):
      """Econde a row of pixels.
      This function is a generator used during the compression phase. More
      information on packets generated are after returns section."""
      pass
      # ...
#+END_SRC
* Nuitka
#+BEGIN_QUOTE
Nuitka is a Python compiler.
It's fully compatible with Python 2.7 .. 3.4.

You feed it your Python app, it does a lot of clever things, and spits out an executable or extension module.
#+END_QUOTE

If interpreting things is slow, why not compile it? Sounds crazy? think again!
** 
~nuitka --recurse-all program.py~ and you are set. ~recurse-all~ option will transverse the dependencies tree and compile them to, one by one.
* PyPy
#+BEGIN_QUOTE
PyPy is a fast, compliant alternative implementation of the Python language (2.7.12 and 3.3.5). It has several advantages and distinct features, speed, memory usage, compatibility, stackless
#+END_QUOTE
** 

Get a huge speed improvement by just replacing ~python~ with ~pypy~ 

eg: ~pypy program.py~. To good to be true? Yes, yes it is! 

Two things: warmup time and incompatibility with all those good python modules written with the help of C. 

* Nim
#+BEGIN_QUOTE
Nim (formerly known as "Nimrod") is a statically typed, imperative programming language that tries to give the programmer ultimate power without compromises on runtime efficiency. This means it focuses on compile-time mechanisms in all their various forms.
#+END_QUOTE
** Elevator pitch
*** Nim is efficient
Native code generation (currently via compilation to C), not dependent on a virtual machine: Nim produces small executables without dependencies for easy redistribution.
*** Nim is efficient
A fast non-tracing garbage collector that supports soft real-time systems (like games).
*** Nim is efficient
System programming features: Ability to manage your own memory and access the hardware directly. Pointers to garbage collected memory are distinguished from pointers to manually managed memory.
*** Nim is efficient
Zero-overhead iterators.

Cross-module inlining.

Dynamic method binding with inlining and without virtual method table.

Compile time evaluation of user-defined functions.
*** Nim is efficient
Whole program dead code elimination: Only used functions are included in the executable.

Value-based datatypes: For instance, objects and arrays can be allocated on the stack.
*** Nim is expressive
The Nim compiler and all of the standard libraries are implemented in Nim.

Built-in high level datatypes: strings, sets, sequences, etc.

Modern type system with local type inference, tuples, variants, generics, etc.

User-defineable operators; code with new operators is often easier to read than code which overloads built-in operators. For example, a =~ operator is defined in the re module.

Macros can modify the abstract syntax tree at compile time.
*** Nim is elegant
Macros can use the imperative paradigm to construct parse trees. Nim does not require a different coding style for meta programming.

Macros cannot change Nim's syntax because there is no need for it. Nim's syntax is flexible enough.

Statements are grouped by indentation but can span multiple lines. Indentation must not contain tabulators so the compiler always sees the code the same way as you do.
*** Nim plays nice with others
The Nim Compiler runs on Windows, Linux, BSD and Mac OS X. Porting to other platforms is easy.

The Nim Compiler can also generate C++ or Objective C for easier interfacing.
There are lots of bindings: for example, bindings to GTK2, the Windows API, the POSIX API, OpenGL, SDL, Cairo, Python, Lua, TCL, X11, libzip, PCRE, libcurl, mySQL and SQLite are included in the standard distribution or can easily be obtained via the Nimble package manager.

A C to Nim conversion utility: New bindings to C libraries are easily generated by c2nim.
** Nim for Python programmers
Similarities and differences.
** 
#+ATTR_HTML: :style font-size: 50%
| Feature                  | Python                               | Nim                             |
|--------------------------+--------------------------------------+---------------------------------|
| Execution model          | Virtual Machine, JIT                 | Machine code via C*             |
| Meta-programming         | Python (decorators/metaclasses/eval) | Nim (const/when/template/macro) |
| Memory Management        | Garbage-collected                    | Garbage-collected and manual    |
| Types                    | Dynamic                              | Static                          |
| Dependent types          | -                                    | Partial support                 |
| Generics                 | Duck typing                          | Yes                             |
| int8/16/32/64 types      | No                                   | Yes                             |
| Bigints (arbitrary size) | Yes (transparently)                  | Yes (via nimble package)        |
| Arrays                   | Yes                                  | Yes                             |
| Bounds-checking          | Yes                                  | Yes                             |
| Type inference           | Duck typing                          | Yes (extensive support)         |
| Closures                 | Yes                                  | Yes                             |
| Operator Overloading     | Yes                                  | Yes (on any type)               |
| Custom Operators         | No                                   | Yes                             |
| Object-Oriented          | Yes                                  | Minimalistic**                  |
| Methods                  | Yes                                  | Yes                             |
| Multi-Methods            | No                                   | Yes                             |
| Exceptions               | Yes                                  | Yes                             |

 \*Other backends supported and/or planned
 \** Can be achieved with macros
* Nim-pymod
- Auto-generates a Python module that wraps a Nim module
- pymod consists of Nim bindings & Python scripts to automate the generation of Python C-API extensions
- There's even a PyArrayObject that provides a Nim interface to Numpy arrays.
** 
#+BEGIN_SRC nim
  ## Compile this Nim module using the following command:
  ##   python path/to/pmgen.py greeting.nim

  ## Taken directly from the projects README

  import strutils  # `%` operator

  import pymod
  import pymodpkg/docstrings

  proc greet*(audience: string): string {.exportpy.} =
    docstring"""Greet the specified audience with a familiar greeting.

  The string returned will be a greeting directed specifically at that audience.
    """
    return "Hello, $1!" % audience

  initPyModule("hw", greet)
#+END_SRC
** 
#+BEGIN_SRC
  >>> import hw
  >>> hw.greet
  <built-in function greet>
  >>> hw.greet("World")
  'Hello, World!'
  >>> help(hw.greet)
  Help on built-in function greet in module hw:

  greet(...)
      greet(audience: str) -> (str)

      Parameters
      ----------
      audience : str -> string

      Returns
      -------
      out : (str) <- (string)

      Greet the specified audience with a familiar greeting.

      The string returned will be a greeting directed specifically at that audience.
  >>>
#+END_SRC
** Procedure parameter & return types

The following Nim types are currently supported by Pymod:

#+ATTR_HTML: :style font-size: 60%
| Type family           | Nim types                                                                           | Python2 type    | Python3 type    |
|-----------------------+-------------------------------------------------------------------------------------+-----------------+-----------------|
| floating-point        | `float`, `float32`, `float64`, `cfloat`, `cdouble`                                  | `float`         | `float`         |
| signed integer        | `int`, `int16`, `int32`, `int64`, `cshort`, `cint`, `clong`                         | `int`           | `int`           |
| unsigned integer      | `uint`, `uint8`, `uint16`, `uint32`, `uint64`, `cushort`, `cuint`, `culong`, `byte` | `int`           | `int`           |
| non-unicode character | `char`, `cchar`                                                                     | `str`           | `bytes`         |
| string                | `string`                                                                            | `str`           | `str`           |
| Numpy array           | `ptr PyArrayObject`                                                                 | `numpy.ndarray` | `numpy.ndarray` |

** Support for the following Nim types is in development: 

#+ATTR_HTML: :style font-size: 60%
| Type family                    | Nim types           | Python2 type | Python3 type  |
|--------------------------------+---------------------+--------------+---------------|
| signed integer                 | `int8`              | `int`        | `int`         |
| boolean                        | `bool`              | `bool`       | `bool`        |
| unicode code point (character) | `unicode.Rune`      | `unicode`    | `str`         |
| non-unicode character sequence | `seq[char]`         | `str`        | `bytes`       |
| unicode code point sequence    | `seq[unicode.Rune]` | `unicode`    | `str`         |
| sequence of a single type _T_  | `seq[T]`            | `list`       | `list`        |

** Going Commando: ditching pymod and using ctypes
Original blog post here: http://akehrer.github.io/posts/connecting-nim-to-python/
#+BEGIN_SRC nim
  # median_test.nim
  proc median*(x: openArray[float]): float {. exportc, dynlib .} =
    ## Computes the median of the elements in `x`.
    ## If `x` is empty, NaN is returned.
    if x.len == 0:
      return NAN

    var sx = @x # convert to a sequence since sort() won't take an openArray
    sx.sort(system.cmp[float])

  if sx.len mod 2 == 0:
    var n1 = sx[(sx.len - 1) div 2]
    var n2 = sx[sx.len div 2]
    result = (n1 + n2) / 2.0
  else:
    result = sx[(sx.len - 1) div 2]
#+END_SRC

** Python Code
#+BEGIN_SRC python
  from ctypes import *

  def main():
      test_lib = CDLL('median_test')

      # Function parameter types
      test_lib.median.argtypes = [POINTER(c_double), c_int]

      # Function return types
      test_lib.median.restype = c_double

      # Calc some numbers
      nums = [1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0]
      nums_arr = (c_double * len(nums))()
      for i,v in enumerate(nums):
          nums_arr[i] = c_double(v)

      med_res = test_lib.median(nums_arr, c_int(len(nums_arr)))
      print('The median of %s is: %f'%(nums, med_res))

  if __name__ == '__main__':
      main()
#+END_SRC

** Compile and run
#+BEGIN_SRC 
  $nim c -d:release --app:lib median_test.nim
  $python median.py
  The median of [1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0] is: 4.500000
#+END_SRC
** TODO: How do we know the arguments type?
* Did I get out of trouble?
** PC specs
- Motherboard: *IP35*
- CPU: *Intel(R) Xeon(R) X5460 @ 3.16GHz 4 cores*
- Memory: *DDR2 4GiB @ 800MHz*
- HDD: *Seagate Baracuda* x 2 *RAID0*
** 
#+BEGIN_SRC python
  import os
  from subprocess import call

  BASE_PATH = os.path.join(os.getcwd(), 'images')

  def st_time(func):
      from functools import wraps
      import time

      @wraps(func)
      def st_func(*args, **kwargs):
          t1 = time.time()
          func(*args, **kwargs)
          t2 = time.time()
          return t2 - t1

      return st_func


  @st_time
  def cpython(image_path):
      from pyTGA.measure import main
      return main(image_path)


  @st_time
  def pypy(image_path):
      return call(["pypy", "pyTGA/measure.py", image_path])

  # ...

#+END_SRC
** 
#+BEGIN_SRC python
  # start the x axis at 0
  x = [0, 15, 150, 512, 1024, 2048, 4096]
  tests = [cpython, pypy, nuitka, nim, pymod_nim]
  images = ["pie_15_11.tga", "pie_150_113.tga",
            "pie_512_384.tga", "pie_1024_768.tga",
            "pie_2048_1536.tga", "pie_4096_3072.tga"]

  for t in tests:
      res = [0, ]    # 0 because we want to start from the same point on both axis
      for image in images:
          image_path = os.path.join(BASE_PATH, image)
          # res will be ploted with matplotlib
          res.append(t(image_path))
          print "benchmarking: {} with size: {}".format(t.__name__, image)
#+END_SRC
** Results
 [[/home/vlad/Experiments/nimtga/presentation/benchmark.png]]
** Detail view on the fastest three
 [[/home/vlad/Experiments/nimtga/presentation/benchmark_top_3.png]]
** Detail view on small execution time
 [[/home/vlad/Experiments/nimtga/presentation/benchmark_small_images.png]]
* Hello, is it Nim you're looking for?
** TODO: introduction
** Use cases
** Language features
** Macros, C integration
